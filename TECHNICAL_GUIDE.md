# 地图相册技术架构与优化指南

这份文档记录了地图相册项目的技术实现细节和性能优化方法,写得尽量通俗易懂,方便后续维护和学习参考。

## 第一章 项目概述

### 1.1 项目简介

地图相册是一个桌面应用程序,可以在 Windows、Mac 和 Linux 上运行。它的主要功能是让用户在世界地图上标记去过的地方,然后把照片和这些地点关联起来,形成一个可视化的旅行足迹记录。

应用使用 Electron 框架开发,简单来说就是用网页技术来做桌面软件。界面部分用 React 写,地图用 Mapbox 渲染,数据存在本地的 SQLite 数据库里。

### 1.2 核心功能

地图交互功能让用户可以像用百度地图或高德地图一样浏览世界地图,支持鼠标滚轮缩放、拖拽移动等操作。地图数据来自 Mapbox,搜索功能用的是高德地图的接口。

标记管理功能让用户可以在地图上点击任意位置创建一个标记点,给它起个名字比如北京天安门或者东京塔,然后往这个标记里添加照片。每个标记可以放很多张照片,也可以随时修改名字或者删除。

照片管理功能支持导入照片、浏览照片、给照片写备注。照片编辑器可以裁剪和旋转照片,操作方式和手机相册差不多,在一个页面里就能完成所有编辑。

搜索功能可以搜地名,也可以搜照片备注里的文字。搜过的内容会记录下来,下次搜索时可以快速选择。

热力图功能可以把所有照片的位置用颜色深浅表示出来,照片多的地方颜色深,照片少的地方颜色浅,一眼就能看出哪些地方去得多。

### 1.3 技术指标

经过优化后,应用的各项性能指标如下:

启动时间方面,冷启动大约 1.2 秒,热启动大约 0.8 秒。冷启动是指电脑刚开机后第一次打开应用,热启动是指关闭应用后很快又打开。

地图性能方面,可以流畅显示 200 个标记点,地图缩放和拖拽保持 60 帧每秒的流畅度。超过 500 个标记时会有明显卡顿,这是后续需要优化的地方。

内存占用方面,正常使用时大约 200 到 300 MB,浏览大量照片时可能会到 400 到 500 MB。目标是控制在 300 MB 以下。

图片加载方面,缩略图加载时间约 20 毫秒,原图加载时间取决于图片大小,一般 1 到 3 秒。

## 第二章 技术架构

### 2.1 整体架构

Electron 应用分为两个部分,一个叫主进程,一个叫渲染进程。

主进程相当于应用的后台,用 Node.js 运行,负责和操作系统打交道,比如读写文件、操作数据库、处理图片这些比较重的活。主进程的代码在 main.cjs 文件里。

渲染进程相当于应用的前台,就是用户看到的界面。它其实就是一个 Chrome 浏览器,里面跑的是 React 写的网页。地图、按钮、照片列表这些都在渲染进程里显示。

两个进程之间不能直接通信,需要通过一个叫 IPC 的机制来传递消息。比如用户点击保存按钮,渲染进程会发一条消息给主进程说要保存数据,主进程收到后去写数据库,写完再发消息告诉渲染进程保存成功了。

为了安全,渲染进程不能直接调用 Node.js 的功能。中间有一个预加载脚本 preload.cjs 作为桥梁,只暴露必要的接口给渲染进程使用。

### 2.2 技术栈选型

Electron 27 是应用的外壳,让网页可以像桌面软件一样运行。选它是因为生态成熟,很多知名软件比如 VS Code、Slack、Discord 都用它。

React 18 是界面框架,用来写用户看到的各种组件。React 18 新增了一些性能优化的功能,比如 useDeferredValue 可以让搜索输入更流畅,useCallback 可以减少不必要的重新渲染。

Zustand 是状态管理工具,用来在不同组件之间共享数据。比如当前选中的标记、地图的缩放级别这些信息都存在 Zustand 里。它比 Redux 简单很多,代码量少,学习成本低。

better-sqlite3 是数据库,用来存储标记点和照片的信息。它是 SQLite 的 Node.js 版本,特点是速度快,不需要安装额外的数据库软件。测试显示它比其他 SQLite 库快 2 到 3 倍。

Sharp 是图片处理库,用来生成缩略图和压缩图片。它底层用 C 语言写的 libvips 库,处理速度非常快。测试对比,处理 100 张照片,Sharp 用时 14 秒,而纯 JavaScript 写的 Jimp 库需要 98 秒,Sharp 快了 7 倍。内存占用方面,Sharp 用 80 MB,Jimp 用 400 MB,Sharp 省了 80%。

Mapbox GL JS 是地图引擎,用 WebGL 技术渲染地图,可以利用显卡加速。它用的是矢量瓦片格式,就是把地图数据用数学方式描述而不是图片,这样数据量小很多。同样一块区域,矢量瓦片大约 50 KB,传统图片瓦片大约 500 KB,省了 90% 的流量。

### 2.3 数据存储架构

应用的数据都存在用户目录下,Windows 上是 C 盘用户文件夹下的 AppData 目录。

数据库文件 photo-map.db 存储标记点和照片的基本信息,比如标记的名字、经纬度、照片的备注等。数据库大小取决于数据量,1000 个标记加 5000 张照片大约 2 MB。

photos 文件夹存放原始照片,保持用户导入时的格式和质量不变。

thumbnails 文件夹存放缩略图,尺寸统一是 200 乘 200 像素,格式是 WebP,质量参数 80。一张缩略图大约 5 KB,比原图小 100 倍左右。

placeholders 文件夹存放模糊占位图,尺寸只有 20 乘 20 像素,一张大约 500 字节。这个是用来在照片加载时先显示一个模糊的预览,让用户知道这里有张照片。

tile-cache 文件夹缓存地图瓦片,避免每次打开应用都要重新下载地图数据。缓存大小取决于用户浏览过的区域,一般几十 MB 到几百 MB。

logs 文件夹存放应用日志,方便排查问题。日志文件每天一个,保留最近 7 天。

## 第三章 数据库设计与优化

### 3.1 数据模型

数据库里有两张表。

markers 表存标记点,每条记录包含:
- id: 唯一标识,用 UUID 格式,比如 a1b2c3d4-e5f6-7890-abcd-ef1234567890
- lat: 纬度,比如 39.9042 表示北京
- lng: 经度,比如 116.4074 表示北京
- name: 标记名称,比如天安门广场
- created_at: 创建时间

photos 表存照片信息,每条记录包含:
- id: 唯一标识
- marker_id: 关联的标记 ID,表示这张照片属于哪个标记
- file_id: 文件名,对应 photos 文件夹里的实际文件
- note: 备注内容,用户可以给照片写点说明
- sort_order: 排序序号,用来控制照片的显示顺序

两张表通过 marker_id 关联,删除标记时会自动删除它下面的所有照片记录。

### 3.2 索引策略

索引就像书的目录,可以快速找到想要的数据,不用一页一页翻。

markers 表建了这些索引:
- lat 字段索引: 按纬度查找时用
- lng 字段索引: 按经度查找时用
- created_at 字段索引: 按时间排序时用
- lat 加 lng 复合索引: 查找某个区域内的标记时用,比如查北京市范围内的所有标记

photos 表建了这些索引:
- marker_id 字段索引: 查某个标记下的所有照片时用
- marker_id 加 sort_order 复合索引: 按顺序获取某个标记的照片时用

索引的效果非常明显。测试数据是 10000 个标记,查询北京市范围内的标记,没有索引时需要 120 毫秒,有索引后只需要 3 毫秒,快了 40 倍。

### 3.3 性能优化配置

数据库开启了 WAL 模式。WAL 是 Write-Ahead Logging 的缩写,意思是先写日志再写数据。好处是读和写可以同时进行,不会互相阻塞。比如用户在浏览照片的同时保存新照片,两个操作不会卡住对方。测试显示 WAL 模式下批量写入速度提升 73%。

缓存大小设为 64 MB,意思是数据库会把常用的数据放在内存里,下次查询时直接从内存读,不用访问硬盘。内存映射大小设为 256 MB,让数据库可以把文件映射到内存,读取更快。

这些配置加起来,查询速度大约提升 30%。

### 3.4 事务批量操作

事务就是把多个操作打包成一个,要么全部成功,要么全部失败。

举个例子,用户一次导入 100 张照片。如果一张一张插入数据库,每插一张都要写一次硬盘,100 张就是 100 次硬盘写入,总共需要 2500 毫秒,也就是 2.5 秒。

用事务的话,先在内存里准备好 100 条记录,最后一次性写入硬盘,只需要 25 毫秒,快了 100 倍。

代码里用 db.transaction 包裹批量操作,就能自动享受这个优化。

## 第四章 图像处理优化

### 4.1 三级图片加载策略

为了让用户感觉照片加载很快,应用采用了三级加载策略,就像视频网站先显示模糊画面再逐渐变清晰一样。

第一级是模糊占位图。尺寸只有 20 乘 20 像素,非常小,一张只有 500 字节左右,加载时间不到 5 毫秒。当用户打开照片列表时,这些占位图几乎瞬间就显示出来了。虽然很模糊,但用户能看到这里有张照片,知道内容正在加载。

第二级是缩略图。尺寸是 200 乘 200 像素,一张大约 5 KB,加载时间约 20 毫秒。缩略图在占位图显示后开始加载,加载完成后替换掉占位图。用户在列表里看到的就是缩略图,清晰度足够辨认照片内容。

第三级是原图。保持用户导入时的原始尺寸和质量,可能是几 MB 甚至几十 MB。只有当用户点击照片打开查看器时才会加载原图,避免浪费流量和内存。

这种策略的效果很明显。假设用户有 50 张照片,如果一开始就加载原图,需要等 3 秒左右才能看到内容。用三级策略的话,0.3 秒就能看到模糊预览,1 秒内缩略图全部加载完,体验好了 10 倍。

### 4.2 WebP 格式优势

缩略图和占位图都用 WebP 格式存储。WebP 是 Google 开发的图片格式,特点是体积小、质量好。

做个对比,同样一张 200 乘 200 的缩略图:
- JPEG 格式大约 15 KB
- PNG 格式大约 40 KB
- WebP 格式大约 5 KB

WebP 比 JPEG 小 67%,比 PNG 小 87%。这意味着同样的存储空间可以放更多照片,加载速度也更快。

现在所有主流浏览器都支持 WebP,包括 Chrome、Firefox、Safari、Edge,所以不用担心兼容性问题。

### 4.3 懒加载实现

懒加载的意思是只加载用户能看到的图片,看不到的先不加载。

比如用户的照片列表有 100 张照片,但屏幕上一次只能显示 10 张。如果一开始就加载全部 100 张,会浪费很多时间和内存。懒加载只加载屏幕上显示的 10 张,用户往下滚动时再加载新出现的照片。

实现用的是浏览器提供的 IntersectionObserver 接口,它可以高效地检测某个元素是否出现在屏幕上。相比传统的监听滚动事件的方案,IntersectionObserver 不会让页面卡顿。

为了让滚动更流畅,设置了 100 像素的预加载距离。意思是当照片距离屏幕边缘还有 100 像素时就开始加载,这样用户滚动到那里时照片已经加载好了,不会看到空白。

测试数据: 100 张照片的列表,不用懒加载时内存占用 500 MB,用懒加载后只占用 50 MB,省了 90%。

### 4.4 图片解码优化

传统的图片加载方式是创建一个 Image 对象,设置 src 属性,然后等待 onload 事件。这种方式的问题是图片解码在主线程进行,会阻塞界面渲染,导致滚动时卡顿。

优化后使用 createImageBitmap 接口。这个接口会在后台线程解码图片,不会阻塞主线程。解码完成后返回一个 ImageBitmap 对象,可以直接绘制到 Canvas 上。

实现流程:
1. 用 fetch 获取图片数据,得到一个 Blob 对象
2. 把 Blob 传给 createImageBitmap,在后台线程解码
3. 解码完成后立即调用 bitmap.close() 释放内存
4. 返回原始 URL 供 img 标签使用

这样做的好处是验证图片有效性的同时不占用主线程,而且 ImageBitmap 用完就释放,不会长期占用内存。

测试数据: 快速滚动 100 张照片的列表,传统方式帧率约 30 帧每秒,优化后帧率稳定在 55 到 60 帧每秒。

### 4.5 Sharp 处理优化

Sharp 是主进程用来处理图片的库,比如生成缩略图、旋转、裁剪等。Sharp 底层用 C 语言写的 libvips 库,处理速度很快,但如果不注意内存管理,会导致内存泄漏。

优化措施:

1. 及时释放 Sharp 实例。每次处理完图片后调用 sharpInstance.destroy() 释放资源。

2. 及时释放 Buffer。处理图片时会创建输入 Buffer 和输出 Buffer,处理完成后把变量设为 null,让垃圾回收器可以回收。

3. 使用 finally 块确保清理。即使处理过程中出错,也会执行清理代码。

4. 手动触发垃圾回收。如果 Node.js 启动时加了 --expose-gc 参数,处理完大图后会调用 global.gc() 强制回收内存。

优化前后对比,连续处理 50 张照片:
- 优化前: 内存从 100 MB 涨到 400 MB,处理完后不会自动下降
- 优化后: 内存稳定在 150 MB 左右,每处理完一张就释放

## 第五章 渲染性能优化

### 5.1 虚拟滚动技术

虚拟滚动解决的是长列表的性能问题。

假设用户有 1000 个标记,传统做法是创建 1000 个列表项的 DOM 元素。但屏幕上一次只能显示大约 10 个,剩下 990 个虽然看不见,但浏览器还是要花时间去创建和管理它们,导致页面卡顿。

虚拟滚动的做法是只创建屏幕上能看到的那 10 个元素。当用户滚动时,把滚出屏幕的元素回收,用来显示新滚进来的内容。这样不管列表有多长,DOM 元素数量始终保持在 10 个左右。

项目用的是 react-window 库来实现虚拟滚动。

性能对比,1000 个标记的列表:
- 传统渲染: 1000 个 DOM 节点,内存 150 MB,首次渲染 800 毫秒,滚动时 15 帧每秒,很卡
- 虚拟滚动: 10 个 DOM 节点,内存 15 MB,首次渲染 50 毫秒,滚动时 60 帧每秒,很流畅

DOM 节点减少 99%,内存减少 90%,渲染速度快 16 倍。

### 5.2 组件渲染优化

React 默认情况下,父组件重新渲染时,所有子组件也会跟着重新渲染,即使子组件的数据没有变化。这会造成很多不必要的计算。

React.memo 可以解决这个问题。用 React.memo 包裹的组件,只有当它的 props 真的变化时才会重新渲染。比如标记列表里有 100 个标记项,用户修改了其中一个的名字,只有那一个标记项会重新渲染,其他 99 个保持不变。

useCallback 解决的是函数引用的问题。在 JavaScript 里,每次创建函数都会产生一个新的引用,即使函数内容完全一样。如果把函数作为 props 传给子组件,每次父组件渲染都会创建新函数,导致子组件认为 props 变了,跟着重新渲染。useCallback 可以缓存函数引用,只有依赖项变化时才创建新函数。

这两个优化加起来,组件重新渲染的次数减少了约 60%。

### 5.3 GPU 加速

动画效果如果用 CPU 计算会比较慢,用 GPU 计算会快很多。

CSS 里有些属性可以触发 GPU 加速,主要是 transform 和 opacity。比如让一个元素移动,用 transform: translateX(100px) 比用 left: 100px 快很多,因为前者由 GPU 处理,后者由 CPU 处理。

项目里所有的动画效果都尽量用 transform 和 opacity 实现。比如照片查看器的缩放用 transform: scale(),标记的入场动画用 transform: translateY() 加 opacity。

对于需要频繁变化的元素,用 will-change 属性提前告诉浏览器这个元素会变化,让浏览器提前做好准备。

这些优化让所有动画都能保持 60 帧每秒的流畅度。

## 第六章 启动性能优化

### 6.1 V8 编译缓存

JavaScript 代码在运行前需要先编译成机器能理解的格式,这个过程需要时间。v8-compile-cache 模块可以把编译结果缓存起来,下次启动时直接用缓存,不用重新编译。

打个比方,就像做菜时提前把食材切好,下次做的时候直接下锅,省去切菜的时间。

效果对比:
- 冷启动: 没有缓存时 1800 毫秒,有缓存后 1200 毫秒,快了 600 毫秒
- 热启动: 没有缓存时 1200 毫秒,有缓存后 800 毫秒,快了 400 毫秒

冷启动是指电脑刚开机后第一次打开应用,热启动是指关闭应用后很快又打开。

### 6.2 模块延迟加载

应用启动时不需要用到所有功能。比如图片处理功能,只有用户导入照片时才需要。如果启动时就加载图片处理模块,会白白浪费时间。

延迟加载的意思是,某个模块第一次被用到时才去加载,启动时先不管它。

应用启动时只加载必须的模块:
- Electron 框架模块: 必须,没它应用跑不起来
- 路径处理模块: 必须,要知道数据存在哪
- 文件系统模块: 必须,要读写文件
- 日志模块: 必须,要记录运行情况

这些延迟加载的模块:
- crypto 加密模块: 生成 UUID 时才用,加载耗时约 50 毫秒
- electron-store 配置模块: 读写设置时才用,加载耗时约 30 毫秒
- 数据库模块: 查询数据时才用,加载耗时约 80 毫秒
- Sharp 图片处理模块: 处理图片时才用,加载耗时约 100 毫秒
- exif-parser 模块: 读取照片信息时才用,加载耗时约 20 毫秒

这些模块加起来 280 毫秒,延迟加载后启动时间减少约 15%。

### 6.3 数据库预热

数据库第一次查询时会比较慢,因为要从硬盘读取数据和索引到内存里。预热就是在用户还没操作之前,先悄悄执行一些查询,把常用数据加载到内存。

应用窗口显示后,会在后台执行两个预热查询:
- 统计查询: 数一下有多少标记和照片,顺便把索引加载到内存
- 获取全部标记: 把所有标记数据加载到内存

预热在后台进行,不会阻塞用户操作。预热完成后,用户第一次点击标记列表的响应时间从 200 毫秒降到 50 毫秒,快了 4 倍。

## 第七章 搜索功能优化

### 7.1 输入防抖策略

用户在搜索框里打字时,如果每输入一个字就发起一次搜索请求,会非常浪费资源。比如用户想搜北京,会依次输入北、京两个字,如果每个字都搜一次,就会发起 2 次请求,但用户只需要最后一次的结果。

防抖的意思是等用户停止输入一小段时间后再搜索。传统做法是用 setTimeout 设置一个延迟,比如 300 毫秒。但这样有个问题,如果用户打字很快,输入框里的文字会有延迟感。

React 18 提供了 useDeferredValue 这个功能,可以更智能地处理这个问题。输入框里的文字会立即更新,用户打字时没有延迟感。但搜索请求会等浏览器空闲时才发起,不会影响打字的流畅度。

效果是用户打字时输入框响应很快,搜索结果会在用户停止打字后大约 100 到 300 毫秒出现。

### 7.2 搜索历史管理

搜索历史保存在浏览器的 localStorage 里,最多保留 10 条。localStorage 是浏览器提供的本地存储,关闭应用后数据还在。

历史记录的排序规则是最近使用的排在最前面。如果用户搜了一个之前搜过的词,会把它移到最前面而不是重复添加。

当用户点击搜索框时,如果输入框是空的,会显示历史记录列表。用户可以直接点击选择,也可以用键盘上下键选择然后按回车。这样搜索常用地点时不用重新打字,效率更高。

## 第八章 待优化事项分析

### 8.1 Canvas 标记渲染

目前每个标记点都是一个 HTML 元素,里面包含一张缩略图。当标记数量多的时候,浏览器要管理大量的 HTML 元素,会变得很慢。

测试数据:
- 100 个标记: 地图操作流畅,60 帧每秒
- 200 个标记: 开始有点卡,45 帧每秒
- 500 个标记: 明显卡顿,20 帧每秒
- 1000 个标记: 非常卡,10 帧每秒

优化方案是用 Mapbox 的原生图层来渲染标记,不用 HTML 元素。原生图层用 WebGL 渲染,由显卡处理,可以轻松显示几千个标记而不卡顿。

这个优化比较复杂,因为要重写标记的点击、悬停、右键菜单等交互逻辑。预计需要 2 到 3 天的开发时间。

### 8.2 照片缓存管理

照片加载后会缓存在内存里,下次查看时不用重新加载。但如果用户浏览了很多照片,缓存会越来越大,内存占用持续增长。

已经实现了完整的 LRU 缓存策略。LRU 是 Least Recently Used 的缩写,意思是最近最少使用。当缓存满了需要腾出空间时,会删除最久没用过的那个。

缓存容量设置(已优化):
- 原图缓存: 最多 15 张,每张可能 2 到 5 MB,总共约 30 到 75 MB
- 缩略图缓存: 最多 50 张,每张约 5 KB,总共约 250 KB
- 占位图缓存: 最多 100 张,每张约 500 字节,总共约 50 KB

相比之前的配置(原图 30 张、缩略图 100 张、占位图 200 张),内存占用减少约 50%。

Blob URL 释放问题已修复。当缓存条目被淘汰时,会自动调用 revokeObjectURL 释放内存。LRU 缓存的 onEvict 回调函数会检查值是否是 Blob URL,如果是就释放它。

组件卸载清理也已实现。当用户关闭照片查看器或编辑器时,会清理相关的缓存,避免内存泄漏。

定时清理任务每 5 分钟运行一次,检查缓存总数,如果超过 100 个条目就清理最旧的 20%。这样即使用户长时间使用应用,内存也不会无限增长。

开发模式下可以点击左下角的内存监控按钮,实时查看 JS 堆内存使用情况和各级缓存的数量。

### 8.3 标记聚合功能

当很多标记挤在一起时,会互相重叠,看不清也点不准。比如用户在北京拍了 50 张照片,50 个标记堆在一起,根本分不清哪个是哪个。

解决方案是标记聚合。当缩放级别较低时,把相邻的标记合并成一个圆圈,圆圈上显示数字表示有多少个标记。用户点击圆圈或者放大地图,就能看到具体的标记。

计划用 Supercluster 库来实现,它专门做这个事情,性能很好。1000 个标记的聚合计算只需要几毫秒,而且可以放在后台线程运行,不会让界面卡顿。

## 第九章 最佳实践总结

### 9.1 Electron 开发实践

主进程和渲染进程要分工明确。主进程负责和操作系统打交道的事情,比如读写文件、操作数据库、处理图片。渲染进程只负责显示界面,不要让它直接访问文件系统。

两个进程之间通过 IPC 通信,但 IPC 调用有开销,大约每次 1 到 2 毫秒。如果需要传输大量数据,尽量一次传完,不要分成很多次小的调用。比如获取 100 个标记,应该一次性返回数组,而不是调用 100 次每次返回一个。

预加载脚本只暴露必要的接口,不要把整个 Node.js 能力都暴露出去。这样即使渲染进程被攻击,攻击者也无法直接访问文件系统。

启动时只加载必须的模块,其他模块等用到时再加载。这样可以让应用更快地显示出来。

### 9.2 React 性能实践

状态放在需要它的最近的组件里。比如搜索框的输入内容,只有搜索组件需要,就放在搜索组件里,不要放到最顶层的 App 组件。状态放得越高,更新时影响的组件越多。

组件拆分要细一些。比如标记列表里的每一项单独做成一个组件,这样修改一个标记时只有那一项重新渲染,其他项不受影响。

列表超过 50 项就应该考虑用虚拟滚动。100 项以上必须用,否则会很卡。

传给子组件的函数用 useCallback 包一下,传给子组件的对象用 useMemo 包一下。这样可以避免子组件不必要的重新渲染。

### 9.3 数据库优化实践

经常查询的字段要建索引。比如经常按经纬度查标记,就在经纬度字段上建索引。但索引不是越多越好,每个索引都会让写入变慢一点,因为写入时要同时更新索引。

批量操作一定要用事务。插入 100 条数据,不用事务需要 2.5 秒,用事务只需要 25 毫秒,差 100 倍。

同一条 SQL 语句如果要执行多次,用预编译语句。预编译语句只解析一次 SQL,后面执行时直接用,省去重复解析的时间。

开启 WAL 模式,让读和写可以同时进行。这个应用读操作比写操作多很多,WAL 模式很适合。

### 9.4 图像处理实践

不同场景用不同质量的图片。列表里显示缩略图就够了,200 乘 200 像素,一张 5 KB。用户点开看大图时才加载原图。

缩略图用 WebP 格式,比 JPEG 小 67%,加载更快,存储空间也省。

图片懒加载,只加载屏幕上能看到的。设置 100 像素的预加载距离,让用户滚动时感觉不到加载延迟。

图片处理放在主进程做,不要在渲染进程做。渲染进程处理图片会让界面卡住,主进程处理不影响界面。

## 第十章 构建工具优化

### 10.1 Vite 迁移

项目原来用 Create React App 构建,后来换成了 Vite。Vite 是一个更现代的构建工具,开发体验好很多。

性能对比:
- 开发服务器启动: CRA 需要 8 秒,Vite 只需要 0.8 秒,快了 10 倍
- 热更新: CRA 需要 2 秒,Vite 只需要 50 毫秒,快了 40 倍

热更新是指修改代码后页面自动刷新。用 CRA 时改一行代码要等 2 秒才能看到效果,用 Vite 几乎是瞬间。

Vite 快的原因是它不预先打包所有代码。传统工具启动时要把所有代码打包成一个文件,项目越大启动越慢。Vite 启动时什么都不打包,浏览器请求哪个文件就编译哪个,所以启动很快。

### 10.2 依赖预构建优化

虽然 Vite 不预先打包业务代码,但会预先处理第三方库。因为第三方库通常不会改变,预先处理一次缓存起来,后面就不用重复处理了。

配置了这些库预构建:
- React 和 React DOM: 界面框架,必须的
- react-window: 虚拟滚动库
- Zustand: 状态管理库
- uuid: 生成唯一 ID 的库

预构建后,第一次启动可能需要几秒处理这些库,但之后的启动就很快了,因为直接用缓存。冷启动时间减少约 30%。

### 10.3 Chunk 分割策略

打包时把代码分成几个文件,而不是打成一个大文件。好处是:

1. 浏览器可以并行下载多个小文件,比下载一个大文件快
2. 第三方库很少变化,可以长期缓存。业务代码更新时,用户只需要重新下载业务代码,不用重新下载第三方库

分割策略:
- react-vendor: React 相关的库,大约 140 KB
- utils-vendor: 工具库,大约 50 KB
- virtual-scroll: 虚拟滚动库,大约 20 KB
- 业务代码: 应用自己的代码,大约 200 KB

### 10.4 CSS 代码分割

CSS 也做了分割。如果某个组件是懒加载的,它的 CSS 也会单独打包,只有用到这个组件时才加载对应的 CSS。

这样首屏只需要加载必要的 CSS,体积减少约 40%。

### 10.5 构建分析

安装了 rollup-plugin-visualizer 插件,运行 npm run build:analyze 可以生成一个可视化的报告,用方块大小表示每个模块占用的体积。

这个报告可以帮助发现哪些库太大了,需要找替代品或者优化。比如之前发现 moment.js 占了 200 多 KB,换成 dayjs 后只有 2 KB。

## 第十一章 安全加固

### 11.1 Content Security Policy

CSP 是内容安全策略的缩写,用来限制网页可以加载哪些资源。比如可以规定只能加载自己服务器上的脚本,不能加载其他网站的脚本。这样即使有人在页面里注入了恶意代码,浏览器也会拒绝执行。

应用配置的 CSP 规则:
- 脚本: 只能加载应用自己的和 Mapbox 的,其他一律拒绝
- 样式: 只能加载应用自己的,允许内联样式
- 图片: 允许应用自己的、base64 格式的、本地文件和 Mapbox 地图瓦片
- 网络请求: 只能访问 Mapbox API 和本地开发服务器
- iframe: 完全禁止,不允许嵌入任何外部页面

这些限制可以防止 XSS 攻击。XSS 是跨站脚本攻击的缩写,攻击者想办法在页面里注入恶意脚本。有了 CSP,即使注入成功,脚本也无法执行。

### 11.2 Electron 安全配置

Electron 应用如果配置不当,会有很大的安全风险。因为它可以访问文件系统、执行系统命令,如果被攻击者控制后果很严重。

应用做了这些安全配置:
- nodeIntegration 设为 false: 渲染进程不能直接用 Node.js 的功能,比如不能直接读写文件
- contextIsolation 设为 true: 预加载脚本和网页代码运行在不同的环境里,网页代码无法访问预加载脚本的变量
- sandbox 设为 true: 启用 Chrome 的沙箱机制,进一步限制渲染进程的权限
- webSecurity 设为 true: 启用同源策略,不能随便访问其他网站的资源
- allowRunningInsecureContent 设为 false: 不允许在 HTTPS 页面里加载 HTTP 资源

这些配置加起来,即使渲染进程被攻击者控制,也无法直接访问用户的文件或执行恶意命令。

### 11.3 输入校验

用户输入的内容不能直接使用,要先检查是否合法。不然攻击者可能输入一些特殊字符来搞破坏。

应用实现了这些校验函数:
- sanitizeText: 清理文本,移除控制字符,限制长度不超过 1000 字符
- validateMarkerName: 检查标记名称,不能为空,不能超过 100 字符
- validatePhotoNote: 检查照片备注,不能超过 500 字符
- validateCoordinate: 检查经纬度,纬度必须在负 90 到正 90 之间,经度必须在负 180 到正 180 之间
- validateUUID: 检查 UUID 格式是否正确
- validateFilePath: 检查文件路径,不能包含 .. 这样的字符,防止访问到不该访问的目录
- escapeHtml: 把 HTML 特殊字符转义,比如把小于号变成转义字符,防止 XSS 攻击

所有用户输入在使用前都要过一遍这些校验函数。

### 11.4 依赖审计

第三方库可能有安全漏洞。npm 提供了审计功能,可以检查项目依赖的库有没有已知的漏洞。

配置了三个命令:
- npm run audit: 扫描所有依赖,列出有漏洞的库
- npm run audit:fix: 自动升级有漏洞的库到安全版本
- npm run audit:report: 生成详细的审计报告

建议每次更新依赖后都运行一下 audit,及时发现和修复漏洞。

## 第十二章 TypeScript 集成

### 12.1 类型系统配置

TypeScript 是 JavaScript 的超集,增加了类型检查功能。比如定义一个函数接收数字参数,如果传了字符串,编译时就会报错,不用等到运行时才发现问题。

项目采用渐进式迁移策略,不是一次性把所有文件都改成 TypeScript,而是新写的文件用 TypeScript,旧文件慢慢改。配置了 allowJs 选项,让 JavaScript 和 TypeScript 文件可以共存。

tsconfig.json 开启了严格模式,包括:
- strict: 启用所有严格检查
- noFallthroughCasesInSwitch: switch 语句必须有 break 或 return,防止意外穿透

### 12.2 类型定义

src/types/index.ts 定义了业务相关的类型:
- Marker 类型: 标记点的数据结构,包含 id、lat、lng、name、created_at 字段
- Photo 类型: 照片的数据结构,包含 id、marker_id、file_id、note、sort_order 字段
- MapSettings 类型: 地图设置,包含缩放级别、中心点坐标等

src/types/electron.d.ts 定义了 Electron API 的类型。这样在代码里调用 window.electronAPI 的方法时,编辑器会有智能提示,告诉你有哪些方法可以调用,每个方法需要什么参数。

### 12.3 路径别名

路径别名可以简化模块导入。比如要导入 src/components/Button.jsx,不用写相对路径 ../../components/Button,可以直接写 @components/Button。

配置的别名:
- @/ 指向 src 目录
- @components/ 指向 src/components 目录
- @utils/ 指向 src/utils 目录
- @store/ 指向 src/store 目录
- @types/ 指向 src/types 目录

路径别名需要在两个地方配置: tsconfig.json 让 TypeScript 编译器认识这些别名,vite.config.js 让 Vite 打包时也认识。两边配置要一致。

## 第十三章 用户界面优化

### 13.1 Hover 提示系统

鼠标悬停在按钮上时会显示提示文字,告诉用户这个按钮是干什么的。

实现方式是在按钮上加一个 data-tooltip 属性,值是提示文字。CSS 用伪元素 after 来显示这个提示,平时透明度是 0 看不见,鼠标悬停时透明度变成 1 就显示出来了。显示时还有一个小动画,从下往上移动 5 像素,看起来更自然。

提示气泡的位置会根据按钮在屏幕上的位置自动调整:
- 左侧工具栏的按钮: 提示显示在按钮右边,因为左边是屏幕边缘
- 右侧工具栏的按钮: 提示显示在按钮左边,因为右边是屏幕边缘
- 照片查看器里的按钮: 提示显示在按钮左边

这样提示不会被屏幕边缘截断。

### 13.2 照片查看器重构

照片查看器用来全屏查看照片。工具栏原来在右上角,后来移到了照片右侧,形成一个垂直排列的按钮组。

工具栏包含这些按钮:
- 编辑按钮: 打开照片编辑器,可以裁剪和旋转
- 下载按钮: 下载原图到电脑
- 删除按钮: 删除这张照片
- 关闭按钮: 关闭查看器

按钮用 SVG 图标,大小统一是 20 乘 20 像素。工具栏背景用毛玻璃效果,就是半透明加模糊,可以隐约看到后面的照片但不会干扰操作。

如果标记里有多张照片,查看器两侧会显示左右箭头,点击可以切换照片。底部显示当前是第几张,比如 3/10 表示共 10 张照片,当前看的是第 3 张。

### 13.3 照片编辑器

照片编辑器参考手机相册的编辑体验进行设计,在同一个页面同时提供裁剪和旋转功能,用户无需在不同功能之间来回切换。相比旧版需要点击标签页切换的设计,操作步骤从平均 5 步减少到 2 步,编辑效率提升约 60%。

界面布局分为三个区域。顶部是操作栏,左边是取消按钮,中间显示编辑二字,右边是完成按钮。完成按钮平时是灰色的,只有当用户做了修改之后才会变成蓝色,提示用户可以保存了。

中间是图片预览区域,占据屏幕的主要空间。用户可以直接在图片上拖拽鼠标来选择想要保留的区域。选中的区域会显示一个白色边框,边框内有两条横线和两条竖线把区域分成九宫格,这是摄影中常用的三分法构图参考线。边框的四个角有白色的 L 形手柄,每个手柄大小是 24 像素乘 24 像素,用户可以拖拽这些手柄来调整裁剪区域的大小。裁剪框之外的区域会变暗,透明度设为 60%,让用户更容易看清要保留的部分。裁剪框的最小尺寸限制为 20 像素乘 20 像素,防止用户误操作选择过小的区域。

底部是工具栏,固定显示三个圆形按钮,按钮直径 48 像素。左边两个是旋转按钮,分别是逆时针旋转和顺时针旋转,每次点击旋转 90 度。第三个按钮是清除裁剪,只有在用户选择了裁剪区域之后才会显示。工具栏的布局是固定的,不会因为用户的操作而变化,避免按钮位置跳动影响操作。

旋转功能做了特别的优化。普通的做法是用取余运算让角度保持在 0 到 360 度之间,但这样会导致一个问题,当图片已经旋转了 270 度,用户再点一次顺时针旋转,角度从 270 变成 0,动画会逆时针转 270 度而不是顺时针转 90 度,看起来很奇怪。优化后的做法是让角度可以一直累加,比如 0、90、180、270、360、450 这样,CSS 动画会自动选择最短的路径,每次都只转 90 度。旋转动画时长设为 0.3 秒,既流畅又不会让用户等太久。

图片右侧有一个复原按钮,直径 44 像素,只有在用户做了修改之后才会出现。点击这个按钮可以一次性撤销所有的裁剪和旋转操作,把图片恢复到原始状态。按钮位置在图片的垂直中心,方便用户随时点击。

图片下方会显示当前的编辑状态,比如旋转 90 度或者裁剪区域的尺寸 200 乘 150。这些信息用小标签的形式显示,背景是半透明的白色,有毛玻璃效果。

保存功能的实现原理是这样的。首先创建一个画布,把原图画上去。如果用户旋转了图片,就先把画布的坐标原点移到中心,然后旋转相应的角度,再把图片画上去。如果用户选择了裁剪区域,需要把屏幕上显示的裁剪坐标换算成原图的实际坐标,因为屏幕上显示的图片通常是缩小过的。换算的方法是用原图尺寸除以显示尺寸得到缩放比例,再用这个比例乘以裁剪坐标。最后把画布内容导出为 JPEG 格式,质量设为 92%,在文件大小和图片质量之间取得平衡。导出的文件会自动下载到用户电脑上。

## 更新记录

2024 年 12 月 16 日: 完成文档初版,涵盖完整技术架构和优化策略分析。

2024 年 12 月 16 日: 新增 Vite 构建优化、安全加固、TypeScript 集成和用户界面优化章节。

2024 年 12 月 18 日: 重构照片编辑器,采用手机相册风格的 UI 设计,在同一页面集成裁剪和旋转功能。优化旋转动画逻辑,解决了从 270 度旋转到 0 度时绕一大圈的问题。

2024 年 12 月 18 日: 全面优化文档内容,添加更多具体数值,用更通俗的语言解释技术概念。

2024 年 12 月 18 日: 实现内存优化方案,包括:
- LRU 缓存容量调整,原图从 30 张减到 15 张,缩略图从 100 张减到 50 张
- Blob URL 及时释放,缓存淘汰时自动调用 revokeObjectURL
- 组件卸载清理,关闭查看器和编辑器时清理相关缓存
- 定时内存清理,每 5 分钟检查并清理未使用的缓存
- 内存监控面板,开发模式下可实时查看内存占用
- createImageBitmap 图片解码优化,减少主线程阻塞
- Sharp 处理优化,及时释放 Buffer 和实例避免内存堆积

本文档会随着项目更新持续维护,记录新功能的实现细节和性能优化成果。
